import Mathlib.AlgebraicTopology.SimplicialSet.StrictSegal
import Mathlib.CategoryTheory.Limits.FunctorCategory.EpiMono

universe u

open CategoryTheory Opposite Simplicial

@[simp]
lemma SimplexCategory.mkOfSucc_zero :
    mkOfSucc (0 : Fin 1) = ùüô _ := by
  ext i
  fin_cases i <;> rfl

namespace SSet

variable {X Y : SSet.{u}} (f : X ‚ü∂ Y)

lemma œÉ_injective {n : ‚Ñï} (i : Fin (n + 1)) : Function.Injective (X.œÉ i) := fun x‚ÇÅ x‚ÇÇ h ‚Ü¶ by
  rw [‚Üê Œ¥_comp_œÉ_self_apply i x‚ÇÅ, ‚Üê Œ¥_comp_œÉ_self_apply i x‚ÇÇ, h]

lemma mono_iff_of_strictSegal [StrictSegal X] :
    Mono f ‚Üî Function.Injective (f.app (op (.mk 1))) := by
  rw [NatTrans.mono_iff_mono_app]
  simp only [mono_iff_injective]
  refine ‚ü®fun hf ‚Ü¶ hf _, fun hf ‚ü®k‚ü© ‚Ü¶ ?_‚ü©
  induction' k using SimplexCategory.rec with k
  obtain _ | k := k
  ¬∑ intro x y h
    apply œÉ_injective 0
    apply StrictSegal.spineInjective
    ext i
    fin_cases i
    apply hf
    dsimp [StrictSegal.spineEquiv]
    simp only [Fin.isValue, SimplexCategory.mkOfSucc_zero, op_id, FunctorToTypes.map_id_apply,
      œÉ_naturality_apply, h]
  ¬∑ intro x y h
    apply StrictSegal.spineInjective
    ext i
    apply hf
    dsimp [StrictSegal.spineEquiv]
    simp only [FunctorToTypes.naturality, h]

namespace standardSimplex

instance (n i : ‚Ñï) : DFunLike (Œî[n] _[i]) (Fin (i + 1)) (fun _ ‚Ü¶ Fin (n + 1)) where
  coe x j := (objEquiv _ _ x).toOrderHom j
  coe_injective' j‚ÇÅ j‚ÇÇ h := by
    apply (objEquiv _ _).injective
    ext k : 3
    exact congr_fun h k

lemma monotone_apply {n i : ‚Ñï} (x : Œî[n] _[i]) : Monotone (fun (j : Fin (i + 1)) ‚Ü¶ x j) :=
  (objEquiv _ _ x).toOrderHom.monotone

@[ext]
lemma ext {n : ‚Ñï} (x y : Œî[n] _[i]) (h : ‚àÄ (i : Fin (i + 1)), x i = y i) : x = y := by
  apply (objEquiv _ _).injective
  ext i : 3
  apply h

@[simps]
def obj‚ÇÄEquiv {n : ‚Ñï} : Œî[n] _[0] ‚âÉ Fin (n + 1) where
  toFun x := x 0
  invFun i := const _ i _
  left_inv x := by ext i : 1; fin_cases i; rfl
  right_inv _ := rfl

instance (n : SimplexCategory) : (standardSimplex.{u}.obj n).StrictSegal where
  spineToSimplex {j v} := objMk
    { toFun i := obj‚ÇÄEquiv (v.vertex i)
      monotone' j‚ÇÅ j‚ÇÇ h := by
        dsimp [obj‚ÇÄEquiv]
        sorry }
  spine_spineToSimplex := sorry
  spineToSimplex_spine := sorry

@[ext]
lemma path_ext {n i : ‚Ñï} {x y : Path Œî[n] i} (h : x.vertex = y.vertex) : x = y := by
  obtain ‚ü®v, a, h‚ÇÅ, h‚ÇÇ‚ü© := x
  obtain ‚ü®w, b, h‚ÇÉ, h‚ÇÑ‚ü© := y
  obtain rfl := h
  dsimp at h‚ÇÉ h‚ÇÑ
  simp only [Path.mk.injEq, true_and]
  ext j k : 2
  fin_cases k
  ¬∑ exact (DFunLike.congr_fun (h‚ÇÅ j) 0).trans (DFunLike.congr_fun (h‚ÇÉ j) 0).symm
  ¬∑ exact (DFunLike.congr_fun (h‚ÇÇ j) 0).trans (DFunLike.congr_fun (h‚ÇÑ j) 0).symm

lemma mono_iff (n : ‚Ñï) (f : Œî[n] ‚ü∂ Y) :
    Mono f ‚Üî Function.Injective (f.app (op [0])):= by
  constructor
  ¬∑ intro hf
    rw [NatTrans.mono_iff_mono_app] at hf
    simp only [mono_iff_injective] at hf
    apply hf
  ¬∑ intro hf
    rw [mono_iff_of_strictSegal]
    intro x‚ÇÅ x‚ÇÇ h
    apply StrictSegal.spineInjective
    ext i : 2
    apply hf
    dsimp [StrictSegal.spineEquiv, spine]
    simp only [FunctorToTypes.naturality, h]

end standardSimplex

end SSet
