import TopCatModelCategory.SSet.HomotopySequence
import TopCatModelCategory.SSet.Fibrations
import TopCatModelCategory.SSet.KanComplexWHomotopy
import Mathlib.CategoryTheory.Adjunction.Unique

universe u

open CategoryTheory Monoidal Simplicial MonoidalCategory MonoidalClosed
  SSet.modelCategoryQuillen HomotopicalAlgebra Opposite
  ChosenFiniteProducts

namespace SSet

variable (X : SSet.{u})

abbrev path := (ihom Œî[1]).obj X

noncomputable def pathEv‚ÇÄ : X.path ‚ü∂ X := (Œî[1].ihomEv (stdSimplex.obj‚ÇÄEquiv.symm 0)).app X

noncomputable def pathEv‚ÇÅ : X.path ‚ü∂ X := (Œî[1].ihomEv (stdSimplex.obj‚ÇÄEquiv.symm 1)).app X

instance [IsFibrant X] : Fibration X.pathEv‚ÇÄ := sorry
instance [IsFibrant X] : Fibration X.pathEv‚ÇÅ := sorry

noncomputable def pathEv‚ÇÄ‚ÇÅ : X.path ‚ü∂ X ‚äó X := lift X.pathEv‚ÇÄ X.pathEv‚ÇÅ

def arrowMkPathEv‚ÇÄ‚ÇÅIso : Arrow.mk X.pathEv‚ÇÄ‚ÇÅ ‚âÖ Arrow.mk ((pre ‚àÇŒî[1].Œπ).app X) := sorry

instance [IsFibrant X] : Fibration X.pathEv‚ÇÄ‚ÇÅ := by
  rw [HomotopicalAlgebra.fibration_iff]
  refine (MorphismProperty.arrow_mk_iso_iff _ X.arrowMkPathEv‚ÇÄ‚ÇÅIso).2 ?_
  rw [‚Üê HomotopicalAlgebra.fibration_iff]
  infer_instance

noncomputable def pathConst : X ‚ü∂ X.path := curry (snd _ _)

variable (x : X _‚¶ã0‚¶å)

noncomputable def constPath : X.path _‚¶ã0‚¶å := X.pathConst.app _ x

lemma constPath_eq : X.constPath x = ihom‚ÇÄEquiv.symm (const x) :=
  ihom‚ÇÄEquiv.injective (by aesop)

@[simp] lemma pathEv‚ÇÄ_app_constPath : X.pathEv‚ÇÄ.app _ (X.constPath x) = x := by
  simp [pathEv‚ÇÄ, constPath_eq, ihomEv_app_app_ihom‚ÇÄEquiv_symm]

@[simp] lemma pathEv‚ÇÅ_app_constPath : X.pathEv‚ÇÅ.app _ (X.constPath x) = x := by
  simp [pathEv‚ÇÅ, constPath_eq, ihomEv_app_app_ihom‚ÇÄEquiv_symm]

abbrev path‚ÇÄ : Subcomplex X.path := Subcomplex.fiber X.pathEv‚ÇÄ x

def loop : Subcomplex X.path := X.path‚ÇÄ x ‚äì Subcomplex.fiber X.pathEv‚ÇÅ x

lemma loop_le_path‚ÇÄ : X.loop x ‚â§ X.path‚ÇÄ x := inf_le_left

lemma constPath_mem_path‚ÇÄ : X.constPath x ‚àà (X.path‚ÇÄ x).obj _ := by
  simp [Subcomplex.mem_fiber_obj_zero_iff]

lemma constPath_mem_loop : X.constPath x ‚àà (X.loop x).obj _ := by
  simp [loop, Subcomplex.mem_fiber_obj_zero_iff]

@[simps]
noncomputable def path‚ÇÄBasePoint : (X.path‚ÇÄ x : SSet) _‚¶ã0‚¶å :=
  ‚ü®_, constPath_mem_path‚ÇÄ _ _‚ü©

@[simps]
noncomputable def loopBasePoint : (X.loop x : SSet) _‚¶ã0‚¶å :=
  ‚ü®_, constPath_mem_loop _ _‚ü©

abbrev loopŒπ : (X.loop x : SSet) ‚ü∂ X.path‚ÇÄ x :=
  Subcomplex.homOfLE (X.loop_le_path‚ÇÄ x)

noncomputable def path‚ÇÄœÄ : (X.path‚ÇÄ x : SSet) ‚ü∂ X := Subcomplex.Œπ _ ‚â´ X.pathEv‚ÇÅ

@[simp]
lemma loopŒπ_app_loopBasePoint : (X.loopŒπ x).app _ (X.loopBasePoint x) = X.path‚ÇÄBasePoint x := rfl

@[simp]
lemma path‚ÇÄœÄ_app_basePoint : (X.path‚ÇÄœÄ x).app _ (X.path‚ÇÄBasePoint x) = x := by
  simp [path‚ÇÄœÄ]

@[reassoc (attr := simp)]
lemma loopŒπ_path‚ÇÄœÄ : X.loopŒπ x ‚â´ X.path‚ÇÄœÄ x = const x := by
  ext n ‚ü®f, hf‚ü©
  simp only [loop, Subpresheaf.min_obj, Set.mem_inter_iff,
    Subcomplex.mem_fiber_obj_iff X.pathEv‚ÇÅ] at hf
  tauto

lemma isPullback_path‚ÇÄ :
    IsPullback (X.path‚ÇÄ x).Œπ (X.path‚ÇÄœÄ x) X.pathEv‚ÇÄ‚ÇÅ
      (lift (const x) (ùüô _)) := by
  let S := Subcomplex.preimage (Subcomplex.ofSimplex x) (fst X X)
  have S_Œπ_fst : S.Œπ ‚â´ fst _ _ = const x := by
    ext n ‚ü®‚ü®y‚ÇÅ, y‚ÇÇ‚ü©, hy‚ü©
    dsimp [S] at hy
    rw [Set.mem_preimage, Subcomplex.mem_ofSimplex‚ÇÄ_obj_iff] at hy
    aesop
  have hS : S.preimage X.pathEv‚ÇÄ‚ÇÅ = X.path‚ÇÄ x := by aesop
  let e : (S : SSet) ‚âÖ X :=
    { hom := S.Œπ ‚â´ snd _ _
      inv := S.lift (lift (const x) (ùüô X)) (by
        apply le_antisymm (by simp)
        rw [‚Üê Subcomplex.image_le_iff, Subcomplex.image_top, ‚Üê Subcomplex.image_le_iff,
          ‚Üê Subcomplex.range_comp, lift_fst, Subcomplex.le_ofSimplex_iff,
          Subcomplex.range_const_Œπ]) }
  exact (Subcomplex.preimage_isPullback S X.pathEv‚ÇÄ‚ÇÅ).of_iso
      (Subcomplex.isoOfEq hS) (Iso.refl _) e (Iso.refl _) rfl rfl (by simp)
      (by ext : 1 <;> aesop)

instance [IsFibrant X] : Fibration (X.path‚ÇÄœÄ x) := by
  rw [HomotopicalAlgebra.fibration_iff]
  exact MorphismProperty.of_isPullback (X.isPullback_path‚ÇÄ x) (by
    rw [‚Üê HomotopicalAlgebra.fibration_iff]
    infer_instance)

lemma loop_eq_fiber : X.loop x = Subcomplex.fiber X.pathEv‚ÇÄ‚ÇÅ ‚ü®x, x‚ü© := by
  ext ‚ü®n‚ü© y
  simp [loop, Subcomplex.mem_fiber_obj_iff, pathEv‚ÇÄ‚ÇÅ]
  rw [Prod.ext_iff]
  dsimp
  rfl

lemma isPullback_loop' :
    IsPullback (X.loop x).Œπ (stdSimplex.objZeroIsTerminal.from _)
      (X.pathEv‚ÇÄ‚ÇÅ) (yonedaEquiv.symm ‚ü®x, x‚ü©) := by
  rw [loop_eq_fiber]
  convert Subcomplex.fiber_isPullback X.pathEv‚ÇÄ‚ÇÅ (x, x)

lemma isPullback_loop :
    IsPullback (X.loopŒπ x) (stdSimplex.objZeroIsTerminal.from _)
      (X.path‚ÇÄœÄ x) (yonedaEquiv.symm x) := by
  rw [‚Üê IsPullback.paste_horiz_iff (X.isPullback_path‚ÇÄ x)]
  ¬∑ convert X.isPullback_loop' x
    aesop
  ¬∑ simp

instance [IsFibrant X] : IsFibrant (X.loop x : SSet) := by
  rw [isFibrant_iff_of_isTerminal (stdSimplex.objZeroIsTerminal.from _)
    stdSimplex.objZeroIsTerminal, HomotopicalAlgebra.fibration_iff]
  exact MorphismProperty.of_isPullback (X.isPullback_loop x) (by
    rw [‚Üê HomotopicalAlgebra.fibration_iff]
    infer_instance)

namespace stdSimplex

@[simps]
def hDelta‚ÇÅOrderHom : Fin 2 √ó Fin 2 ‚Üío Fin 2 :=
  ‚ü®fun ‚ü®x, y‚ü© ‚Ü¶ match x, y with
    | 0, 0 => 0
    | 0, 1 => 0
    | 1, 0 => 0
    | 1, 1 => 1, by
    rw [monotone_prod_iff]
    constructor
    all_goals
    ¬∑ intro i j k _
      fin_cases i <;> fin_cases j <;> fin_cases k <;> aesop‚ü©

def hDelta‚ÇÅ : Œî[1] ‚äó Œî[1] ‚ü∂ Œî[1] :=
  prodStdSimplex.homEquiv.symm hDelta‚ÇÅOrderHom

end stdSimplex

noncomputable def pathHomotopy :
    Homotopy (X.pathEv‚ÇÄ ‚â´ X.pathConst) (ùüô X.path) where
  h := (Œ≤_ _ _).hom ‚â´ curry ((Œ±_ _ _ _).inv ‚â´ uncurry ((pre stdSimplex.hDelta‚ÇÅ).app X))
  h‚ÇÄ := by
    sorry
  h‚ÇÅ := by
    rw [uncurry_pre, Subcomplex.RelativeMorphism.botEquiv_symm_apply_map]
    sorry
  rel := by
    ext _ ‚ü®‚ü®_, h‚ü©, _‚ü©
    simp at h

noncomputable def path‚ÇÄHomotopy :
    Homotopy (const (X.path‚ÇÄBasePoint x)) (ùüô (X.path‚ÇÄ x : SSet)) where
  h := Subcomplex.lift ((X.path‚ÇÄ x).Œπ ‚ñ∑ _ ‚â´ X.pathHomotopy.h) sorry
  rel := by
    ext _ ‚ü®‚ü®_, h‚ü©, _‚ü©
    simp at h

end SSet
