import Mathlib.AlgebraicTopology.RelativeCellComplex.Basic
import Mathlib.CategoryTheory.Limits.Lattice
import TopCatModelCategory.SSet.Degenerate
import TopCatModelCategory.SSet.Evaluation
import TopCatModelCategory.SSet.Monomorphisms

open CategoryTheory Simplicial HomotopicalAlgebra Limits Opposite

namespace SSet

lemma mono_of_nonDegenerate {X : SSet.{u}} {d d' : ‚Ñï} (x : X _‚¶ãd‚¶å)
    (f : ‚¶ãd'‚¶å ‚ü∂ ‚¶ãd‚¶å)
    (h : X.map f.op x ‚àà X.nonDegenerate d') : Mono f := by
  have := isIso_of_nonDegenerate _ ‚ü®_, h‚ü© (factorThruImage f)
    (X.map (image.Œπ f).op x) (by
      rw [‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp, image.fac])
  rw [‚Üê image.fac f]
  infer_instance

variable (X : SSet.{u})

/-- `X.skeleton n` is the subcomplex of `X` generated by (non degenerate)
simplices of dimension `< n`. -/
def skeleton : ‚Ñï ‚Üío X.Subcomplex where
  toFun n := ‚®Ü (i : Fin n) (x : X.nonDegenerate i), Subcomplex.ofSimplex x.1
  monotone' i j h := by
    simp only [iSup_le_iff]
    intro k x
    exact le_trans (by exact le_trans (by rfl) (le_iSup _ x))
      (le_iSup _ ‚ü®k, by omega‚ü©)

lemma mem_skeleton {i : ‚Ñï} (x : X _‚¶ãi‚¶å) {n : ‚Ñï} (hi : i < n) :
    x ‚àà (X.skeleton n).obj _ := by
  obtain ‚ü®j, f, _, y, rfl‚ü© := X.exists_nonDegenerate x
  suffices Subcomplex.ofSimplex y.1 ‚â§ X.skeleton n from
    (X.skeleton n).map _ (this _ (Subcomplex.mem_ofSimplex_obj _))
  exact le_trans (by exact le_trans (by rfl) (le_iSup _ y))
    (le_iSup _ ‚ü®j, lt_of_le_of_lt
      (SimplexCategory.len_le_of_epi (f := f) inferInstance) hi‚ü©)

lemma skeleton_obj_eq_top {d n : ‚Ñï} (h : d < n) :
    (X.skeleton n).obj (op ‚¶ãd‚¶å) = ‚ä§ := by
  rw [‚Üê top_le_iff]
  intro x _
  exact mem_skeleton _ _ h

lemma ofSimplex_le_skeleton {i : ‚Ñï} (x : X _‚¶ãi‚¶å) {n : ‚Ñï} (hi : i < n) :
    Subcomplex.ofSimplex x ‚â§ X.skeleton n := by
  simpa using X.mem_skeleton x hi

lemma mem_skeleton_obj_iff_of_nonDegenerate
    {d : ‚Ñï} (x : X.nonDegenerate d) (n : ‚Ñï) :
    x.1 ‚àà (X.skeleton n).obj _ ‚Üî d < n := by
  constructor
  ¬∑ intro h
    simp [skeleton] at h
    obtain ‚ü®x, hx‚ü© := x
    obtain ‚ü®‚ü®i, hi‚ü©, y, hy, ‚ü®f‚ü©, rfl‚ü© := h
    dsimp at y hy f
    have : d ‚â§ i := SimplexCategory.len_le_of_mono
      (mono_of_nonDegenerate y f hx)
    omega
  ¬∑ apply mem_skeleton

@[simp]
lemma skeleton_zero : X.skeleton 0 = ‚ä• := by
  simp [skeleton]

lemma iSup_skeleton : ‚®Ü (n : ‚Ñï), X.skeleton n = ‚ä§ := by
  apply le_antisymm (by simp)
  rw [Subcomplex.le_iff_contains_nonDegenerate]
  intro n x _
  simp only [Subpresheaf.iSup_obj, Set.mem_iUnion]
  exact ‚ü®n + 1, mem_skeleton _ _ (by omega)‚ü©

variable {X} {Y : SSet.{u}} (i : X ‚ü∂ Y)

def skeletonOfMono [Mono i] : ‚Ñï ‚Üío Y.Subcomplex where
  toFun n := Subcomplex.range i ‚äî Y.skeleton n
  monotone' n m h := by
    dsimp
    simp only [sup_le_iff, le_sup_left, true_and]
    exact le_trans (Y.skeleton.monotone h) le_sup_right

section

variable [Mono i]

lemma skeleton_le_skeletonOfMono (n : ‚Ñï) :
    Y.skeleton n ‚â§ skeletonOfMono i n := le_sup_right

@[simp]
lemma skeletonOfMono_zero : skeletonOfMono i 0 = Subcomplex.range i := by
  simp [skeletonOfMono]

lemma iSup_skeletonOfMono : ‚®Ü (n : ‚Ñï), skeletonOfMono i n = ‚ä§ := by
  apply le_antisymm (by simp)
  rw [‚Üê Y.iSup_skeleton, iSup_le_iff]
  intro n
  exact le_trans (skeleton_le_skeletonOfMono i n) (le_iSup _ n)

lemma mem_skeletonOfMono_obj_iff_of_nonDegenerate
    {d : ‚Ñï} (x : Y.nonDegenerate d) (n : ‚Ñï) :
    x.1 ‚àà (skeletonOfMono i n).obj _ ‚Üî
      x.1 ‚àà Set.range (i.app _) ‚à® d < n := by
  simp [skeletonOfMono, mem_skeleton_obj_iff_of_nonDegenerate]

lemma skeletonOfMono_obj_eq_top {d n : ‚Ñï} (h : d < n) :
    (skeletonOfMono i n).obj (op ‚¶ãd‚¶å) = ‚ä§ := by
  rw [‚Üê top_le_iff, ‚Üê Y.skeleton_obj_eq_top h]
  exact le_sup_right

end

namespace relativeCellComplexOfMono

variable (d : ‚Ñï)

def Œπ [Mono i] : Type u :=
  { y : Y.nonDegenerate d // y.1 ‚àâ (Subcomplex.range i).obj _ }

variable [Mono i]

noncomputable def A : SSet.{u} := ‚àê (fun (_ : Œπ i d) ‚Ü¶ boundary d)

noncomputable def B : SSet.{u} := ‚àê (fun (_ : Œπ i d) ‚Ü¶ Œî[d])

variable {i d}

noncomputable def ŒπA (x : Œπ i d) : (boundary d : SSet) ‚ü∂ A i d :=
  Limits.Sigma.Œπ (fun _ ‚Ü¶ _) x

noncomputable def ŒπB (x : Œπ i d) : Œî[d] ‚ü∂ B i d :=
  Limits.Sigma.Œπ (fun _ ‚Ü¶ _) x

variable (i d) in
noncomputable def m : A i d ‚ü∂ B i d := Limits.Sigma.map (fun _ ‚Ü¶ (boundary d).Œπ)

instance : Mono (m i d) := by
  dsimp [m]
  infer_instance

@[reassoc (attr := simp)]
lemma ŒπA_m (x : Œπ i d) : ŒπA x ‚â´ m i d = (boundary d).Œπ ‚â´ ŒπB x := by
  simp [m, ŒπA, ŒπB]

lemma mem_skeletonOfMono (x : Œπ i d) {d' : ‚Ñï} (h : d < d') :
    x.1.1 ‚àà (skeletonOfMono i d').obj _ := by
  simp only [skeletonOfMono, OrderHom.coe_mk, Subpresheaf.max_obj, Set.mem_union]
  exact Or.inr (Y.mem_skeleton _ h)

def Œ≤ (x : Œπ i d) : Œî[d] ‚ü∂ skeletonOfMono i (d + 1) :=
  yonedaEquiv.symm ‚ü®x.1.1, mem_skeletonOfMono x (by simp)‚ü©

variable (i d) in
noncomputable def b : B i d ‚ü∂ skeletonOfMono i (d + 1) := Sigma.desc Œ≤

@[reassoc (attr := simp)]
lemma ŒπB_b (x : Œπ i d) : ŒπB x ‚â´ b i d = Œ≤ x := by simp [ŒπB, b]

lemma preimage_skeletonOfMono_eq (x : Œπ i d) :
    (skeletonOfMono i d).preimage (yonedaEquiv.symm x.1.1) = ‚àÇŒî[d] := by
  rw [stdSimplex.eq_boundary_iff]
  constructor
  ¬∑ rw [Subcomplex.le_iff_contains_nonDegenerate]
    rintro n ‚ü®y, hy‚ÇÅ‚ü© hy‚ÇÇ
    have : n < d := dim_lt_of_nondegenerate (X := ‚àÇŒî[d])
      (‚ü®‚ü®y, hy‚ÇÇ‚ü©, by rwa [Subcomplex.mem_nonDegenerate_iff]‚ü©) d
    simp [skeletonOfMono_obj_eq_top i this]
  ¬∑ intro h
    have := h.symm.le _ (show stdSimplex.objEquiv.symm (ùüô ‚¶ãd‚¶å)  ‚àà _ by simp)
    simp only [Subpresheaf.range_obj, Subcomplex.preimage_obj, Set.mem_preimage] at this
    change Y.map (ùüô _) x.1.1 ‚àà (skeletonOfMono i d).obj _ at this
    simp only [Subpresheaf.range_obj, FunctorToTypes.map_id_apply,
      mem_skeletonOfMono_obj_iff_of_nonDegenerate, Set.mem_range, lt_self_iff_false,
      or_false] at this
    exact x.2 this

def œÑ (x : Œπ i d) : (‚àÇŒî[d] : SSet) ‚ü∂ skeletonOfMono i d :=
  Subcomplex.lift (‚àÇŒî[d].Œπ ‚â´ yonedaEquiv.symm x.1.1) (by
    rw [Subcomplex.preimage_preimage, preimage_skeletonOfMono_eq,
      Subcomplex.preimage_Œπ])

variable (i d) in
noncomputable def t : A i d ‚ü∂ skeletonOfMono i d := Sigma.desc œÑ

@[reassoc (attr := simp)]
lemma ŒπA_t (x : Œπ i d) : ŒπA x ‚â´ t i d = œÑ x := by simp [ŒπA, t]

variable (i d) in
def r : (skeletonOfMono i d : SSet) ‚ü∂ skeletonOfMono i (d + 1) :=
  Subcomplex.homOfLE ((skeletonOfMono i).monotone (by simp))

@[reassoc]
lemma œÑ_r (x : Œπ i d) : œÑ x ‚â´ r i d = ‚àÇŒî[d].Œπ ‚â´ Œ≤ x := rfl

variable (i d)

@[reassoc]
lemma w : t i d ‚â´ r i d = m i d ‚â´ b i d :=
  Sigma.hom_ext _ _ (fun x ‚Ü¶ by
    change ŒπA x ‚â´ t i d ‚â´ r i d = ŒπA x ‚â´ m i d ‚â´ b i d
    simp [œÑ_r])

lemma isPushout : IsPushout (t i d) (m i d) (r i d) (b i d) := sorry

end relativeCellComplexOfMono

open relativeCellComplexOfMono in
noncomputable def relativeCellComplexOfMono [Mono i] :
    RelativeCellComplex.{u} (basicCell := fun (n : ‚Ñï) (_ : Unit) ‚Ü¶ (boundary n).Œπ) i where
  F := (skeletonOfMono i).monotone.functor ‚ãô Subcomplex.toPresheafFunctor
  isoBot := Subcomplex.isoOfEq (by simp) ‚â™‚â´ (asIso (toRangeSubcomplex i)).symm
  incl :=
    { app _ := Subcomplex.Œπ _
      naturality _ _ _ := rfl }
  isColimit := IsColimit.ofIsoColimit
      (isColimitOfPreserves Subcomplex.toPresheafFunctor
        ((CompleteLattice.colimitCocone
        ((skeletonOfMono i).monotone.functor)).isColimit))
          (Cocones.ext
            ((Subcomplex.isoOfEq (iSup_skeletonOfMono i)) ‚â™‚â´ Subcomplex.topIso Y)
        (fun _ ‚Ü¶ by rfl))
  attachCells d hd :=
    { Œπ := Œπ i d
      œÄ _ := ‚ü®‚ü©
      isColimit‚ÇÅ := colimit.isColimit _
      isColimit‚ÇÇ := colimit.isColimit _
      m := m i d
      hm := ŒπA_m
      g‚ÇÅ := t i d
      g‚ÇÇ := b i d
      isPushout := isPushout i d }

namespace modelCategoryQuillen

open MorphismProperty

noncomputable def transfiniteCompositionOfMono {X Y : SSet.{u}} (i : X ‚ü∂ Y) [Mono i] :
    (coproducts.{u} I).pushouts.TransfiniteCompositionOfShape ‚Ñï i where
  toTransfiniteCompositionOfShape :=
    (relativeCellComplexOfMono i).toTransfiniteCompositionOfShape
  map_mem d hd := by
    apply pushouts_monotone _ _
      ((relativeCellComplexOfMono i).attachCells d hd).pushouts_coproducts
    apply coproducts_monotone
    rintro _ _ _ ‚ü®‚ü©
    exact boundary_Œπ_mem_I d

lemma transfiniteCompositions_pushouts_coproducts :
    transfiniteCompositions.{u} (coproducts.{u} I).pushouts = monomorphisms SSet.{u} := by
  apply le_antisymm
  ¬∑ rw [transfiniteCompositions_le_iff, pushouts_le_iff, coproducts_le_iff]
    exact I_le_monomorphisms
  ¬∑ intro _ _ i (_ : Mono i)
    apply transfiniteCompositionsOfShape_le_transfiniteCompositions _ (ULift ‚Ñï)
    exact ‚ü®(transfiniteCompositionOfMono i).ofOrderIso (orderIsoULift.{u} ‚Ñï).symm‚ü©

lemma I_rlp_eq_monomorphisms_rlp : I.{u}.rlp = (monomorphisms SSet.{u}).rlp := by
  apply le_antisymm
  ¬∑ simp only [‚Üê transfiniteCompositions_pushouts_coproducts,
      rlp_transfiniteCompositions, rlp_pushouts, rlp_coproducts, le_refl]
  ¬∑ exact MorphismProperty.antitone_rlp I_le_monomorphisms

end modelCategoryQuillen

end SSet
