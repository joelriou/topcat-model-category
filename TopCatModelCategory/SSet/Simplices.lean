/-
Copyright (c) 2025 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
import Mathlib.CategoryTheory.Elements
import TopCatModelCategory.SSet.StandardSimplex

/-!
# The type of simplices of a simplicial set

In this file, we define the type `X.S` of simplices of a simplicial set `X`,
where a simplex consists of the data of `dim : ‚Ñï` and `simplex : X _‚¶ãdim‚¶å`.
We endow this type with a preorder defined by
`x ‚â§ y ‚Üî Subcomplex.ofSimplex x.simplex ‚â§ Subcomplex.ofSimplex y.simplex`.

## TODO (@joelriou)

* Extend the `S` structure to define the type of nondegenerate
simplices of a simplicial set `X`, and also the type of nondegenerate
simplices of a simplicial set `X` which do not belong to a given subcomplex.

-/

universe u

open CategoryTheory Simplicial

namespace SSet

variable {X : SSet.{u}}

@[simp]
lemma Subcomplex.ofSimplex_map {n m : ‚Ñï} (f : ‚¶ãn‚¶å ‚ü∂ ‚¶ãm‚¶å) [Epi f]
    (x : X _‚¶ãm‚¶å) :
    ofSimplex (X.map f.op x) = ofSimplex x := by
  apply le_antisymm
  ¬∑ rw [Subpresheaf.ofSection_le_iff]
    exact ‚ü®_, rfl‚ü©
  ¬∑ rw [Subpresheaf.ofSection_le_iff]
    have := isSplitEpi_of_epi f
    exact ‚ü®(section_ f).op, by
      rw [‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp,
        IsSplitEpi.id, op_id, FunctorToTypes.map_id_apply]‚ü©

variable (X) in
/-- The type of simplices of a simpliciat set `X`. -/
structure S where
  /-- the dimension of the simplex -/
  {dim : ‚Ñï}
  /-- the simplex -/
  simplex : X _‚¶ãdim‚¶å

namespace S

@[simp]
lemma mk_simplex (s : X.S) : S.mk s.simplex = s := rfl

lemma mk_surjective (s : X.S) :
    ‚àÉ (n : ‚Ñï) (x : X _‚¶ãn‚¶å), s = mk x :=
  ‚ü®s.1, s.2, rfl‚ü©

/-- The image of a simplex by a morphism of simplicial sets. -/
@[simps]
def map {Y : SSet.{u}} (f : X ‚ü∂ Y) (s : X.S) : Y.S :=
  S.mk (f.app _ s.2)

lemma simplex_map_nonDegenerate_iff_of_mono {Y : SSet.{u}} (f : X ‚ü∂ Y) [Mono f] (s : X.S) :
    (S.map f s).simplex ‚àà Y.nonDegenerate _ ‚Üî s.simplex ‚àà X.nonDegenerate _ := by
  simp [S.map, nonDegenerate_iff_of_mono]

@[simp]
lemma map_id (s : X.S) : S.map (ùüô _) s = s := rfl

lemma map_map {Y Z : SSet.{u}} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (s : X.S) :
    S.map g (S.map f s) = S.map (f ‚â´ g) s := rfl

lemma dim_eq_of_eq {s t : X.S} (h : s = t) :
    s.dim = t.dim :=
  congr_arg dim h

lemma dim_eq_of_mk_eq {n m : ‚Ñï} {x : X _‚¶ãn‚¶å} {y : X _‚¶ãm‚¶å}
    (h : S.mk x = S.mk y) : n = m :=
  dim_eq_of_eq h

section

variable (s : X.S) {d : ‚Ñï} (hd : s.dim = d)

/-- When `s : X.S` is such that `s.dim = d`, this is a term
that is equal to `s`, but whose dimension if definitionally equal to `d`. -/
@[simps dim]
def cast : X.S where
  dim := d
  simplex := _root_.cast (by simp only [hd]) s.simplex

lemma cast_eq_self : s.cast hd = s := by
  obtain ‚ü®d, _, rfl‚ü© := s.mk_surjective
  obtain rfl := hd
  rfl

@[simp]
lemma cast_simplex_rfl : (s.cast rfl).simplex = s.simplex := rfl

end

lemma ext_iff' (s t : X.S) :
    s = t ‚Üî ‚àÉ (h : s.dim = t.dim), (s.cast h).2 = t.2 :=
  ‚ü®by rintro rfl; exact ‚ü®rfl, rfl‚ü©, fun ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© ‚Ü¶ by
    obtain ‚ü®_, _, rfl‚ü© := s.mk_surjective
    obtain ‚ü®_, _, rfl‚ü© := t.mk_surjective
    aesop‚ü©

lemma ext_iff {n : ‚Ñï} (x y : X _‚¶ãn‚¶å) :
    S.mk x = S.mk y ‚Üî x = y := by
  simp

instance : Preorder X.S where
  le x y := Subcomplex.ofSimplex x.2 ‚â§ Subcomplex.ofSimplex y.2
  le_refl _ := le_refl (Œ± := Subcomplex X) _
  le_trans _ _ _ := le_trans (Œ± := Subcomplex X)

-- The subcomplex generated by a simplex. -/
abbrev subcomplex (x : X.S) : X.Subcomplex := Subcomplex.ofSimplex x.2

lemma le_iff {x y : X.S} : x ‚â§ y ‚Üî x.subcomplex ‚â§ y.subcomplex :=
  Iff.rfl

lemma mk_map_le {n m : ‚Ñï} (x : X _‚¶ãn‚¶å) (f : ‚¶ãm‚¶å ‚ü∂ ‚¶ãn‚¶å) :
    S.mk (X.map f.op x) ‚â§ S.mk x := by
  rw [le_iff, Subcomplex.ofSimplex_le_iff]
  exact ‚ü®f.op, rfl‚ü©

lemma mk_map_eq_iff_of_mono {n m : ‚Ñï} (x : X _‚¶ãn‚¶å)
    (f : ‚¶ãm‚¶å ‚ü∂ ‚¶ãn‚¶å) [Mono f] :
    S.mk (X.map f.op x) = S.mk x ‚Üî IsIso f := by
  constructor
  ¬∑ intro h
    obtain rfl := S.dim_eq_of_mk_eq h
    obtain rfl := SimplexCategory.eq_id_of_mono f
    infer_instance
  ¬∑ intro hf
    obtain rfl : n = m :=
      le_antisymm
        (SimplexCategory.len_le_of_epi f)
        (SimplexCategory.len_le_of_mono f)
    obtain rfl := SimplexCategory.eq_id_of_isIso f
    simp

/-- The type of simplices of `X : SSet.{u}` identifies to the type
of elements of `X` considered as a functor `SimplexCategory·µí·µñ ‚•§ Type u`. -/
@[simps!]
def equivElements : X.S ‚âÉ X.Elements where
  toFun s := X.elementsMk _ s.2
  invFun := by
    rintro ‚ü®‚ü®n‚ü©, x‚ü©
    induction n using SimplexCategory.rec
    exact S.mk x
  left_inv _ := rfl
  right_inv _ := rfl

@[simp]
lemma subcomplex_map {Y : SSet.{u}} (f : X ‚ü∂ Y) (x : X.S) :
    (S.map f x).subcomplex = x.subcomplex.image f := by
  simp [subcomplex]

end S

end SSet
